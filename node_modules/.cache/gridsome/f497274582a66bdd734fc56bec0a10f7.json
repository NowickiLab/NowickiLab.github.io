{"remainingRequest":"C:\\Users\\ja03\\NowickiLab.github.io\\node_modules\\babel-loader\\lib\\index.js??ref--1-1!C:\\Users\\ja03\\NowickiLab.github.io\\node_modules\\gridsome\\app\\fetch.js","dependencies":[{"path":"C:\\Users\\ja03\\NowickiLab.github.io\\node_modules\\gridsome\\app\\fetch.js","mtime":1767895352108},{"path":"C:\\Users\\ja03\\NowickiLab.github.io\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1767895345982},{"path":"C:\\Users\\ja03\\NowickiLab.github.io\\node_modules\\babel-loader\\lib\\index.js","mtime":1767895347093}],"contextDependencies":[],"result":["import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.json.stringify.js\";\nimport \"core-js/modules/esnext.json.parse.js\";\nimport prefetch from './utils/prefetch';\nimport { unslashEnd } from './utils/helpers';\nimport { NOT_FOUND_PATH } from '~/.temp/constants';\nconst dataUrl = process.env.DATA_URL;\nconst isPrefetched = {};\nconst isLoaded = {};\nexport default (route, options = {}) => {\n  const {\n    shouldPrefetch = false,\n    force = false\n  } = options;\n  if (!process.isStatic) {\n    const {\n      dynamic = false\n    } = route.meta;\n    let path = dynamic ? route.matched[0].path : route.path;\n    if (route.name === '*') {\n      path = NOT_FOUND_PATH;\n    }\n    return new Promise((resolve, reject) => {\n      const onFail = err => {\n        isLoaded[route.path] = null;\n        reject(err);\n      };\n      const onSuccess = res => {\n        isLoaded[route.path] = null;\n        resolve(res);\n      };\n      if (force || !isLoaded[route.path]) {\n        isLoaded[route.path] = fetch(process.env.GRAPHQL_ENDPOINT, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            path,\n            dynamic\n          })\n        }).then(res => res.json());\n      }\n      isLoaded[route.path].then(res => {\n        if (res.errors) onFail(res.errors[0]);else if (res.code) onSuccess({\n          code: res.code\n        });else onSuccess({\n          data: res.data,\n          context: res.extensions ? res.extensions.context : {}\n        });\n        isLoaded[route.path] = null;\n      }).catch(onFail);\n    });\n  }\n  const hashMeta = document.querySelector('meta[name=\"gridsome:hash\"]').getAttribute('content');\n  return new Promise((resolve, reject) => {\n    const usePath = route.name === '*' ? NOT_FOUND_PATH : route.path;\n    const jsonPath = route.meta.dataPath || unslashEnd(usePath) + '/index.json';\n    const absPath = unslashEnd(dataUrl) + jsonPath;\n    if (shouldPrefetch && !isLoaded[jsonPath]) {\n      if (!isPrefetched[jsonPath]) {\n        isPrefetched[jsonPath] = prefetch(absPath);\n      }\n      return isPrefetched[jsonPath].then(() => resolve()).catch(() => resolve());\n    }\n    if (!isLoaded[jsonPath]) {\n      isLoaded[jsonPath] = fetchJSON(absPath);\n    }\n    return isLoaded[jsonPath].then(res => {\n      if (res.hash !== hashMeta) {\n        reject(createError(`Hash did not match: json=${res.hash}, document=${hashMeta}`, 'INVALID_HASH'));\n      } else {\n        resolve(res);\n      }\n    }).catch(err => {\n      isLoaded[jsonPath] = null;\n      reject(err);\n    });\n  });\n};\nfunction createError(message, code) {\n  const error = new Error(message);\n  error.code = code;\n  return error;\n}\nfunction fetchJSON(jsonPath) {\n  return new Promise((resolve, reject) => {\n    const req = new XMLHttpRequest();\n    req.open('GET', jsonPath, true);\n    req.withCredentials = true;\n    req.onload = () => {\n      switch (req.status) {\n        case 200:\n          {\n            let results;\n            try {\n              results = JSON.parse(req.responseText);\n            } catch (err) {\n              return reject(new Error(`Failed to parse JSON from ${jsonPath}. ${err.message}.`));\n            }\n            if (!results.hash) {\n              return reject(new Error(`JSON data in ${jsonPath} is missing a hash.`));\n            }\n            return resolve(results);\n          }\n        case 404:\n          {\n            return reject(createError(req.statusText, req.status));\n          }\n      }\n      reject(new Error(`Failed to fetch ${jsonPath}.`));\n    };\n    req.onerror = () => {\n      reject(new Error(`Failed to fetch ${jsonPath}.`));\n    };\n    req.send(null);\n  });\n}",{"version":3,"names":["prefetch","unslashEnd","NOT_FOUND_PATH","dataUrl","process","env","DATA_URL","isPrefetched","isLoaded","route","options","shouldPrefetch","force","isStatic","dynamic","meta","path","matched","name","Promise","resolve","reject","onFail","err","onSuccess","res","fetch","GRAPHQL_ENDPOINT","method","headers","body","JSON","stringify","then","json","errors","code","data","context","extensions","catch","hashMeta","document","querySelector","getAttribute","usePath","jsonPath","dataPath","absPath","fetchJSON","hash","createError","message","error","Error","req","XMLHttpRequest","open","withCredentials","onload","status","results","parse","responseText","statusText","onerror","send"],"sources":["C:/Users/ja03/NowickiLab.github.io/node_modules/gridsome/app/fetch.js"],"sourcesContent":["import prefetch from './utils/prefetch'\nimport { unslashEnd } from './utils/helpers'\nimport { NOT_FOUND_PATH } from '~/.temp/constants'\n\nconst dataUrl = process.env.DATA_URL\nconst isPrefetched = {}\nconst isLoaded = {}\n\nexport default (route, options = {}) => {\n  const { shouldPrefetch = false, force = false } = options\n\n  if (!process.isStatic) {\n    const { dynamic = false } = route.meta\n    let path = dynamic ? route.matched[0].path : route.path\n\n    if (route.name === '*') {\n      path = NOT_FOUND_PATH\n    }\n\n    return new Promise((resolve, reject) => {\n      const onFail = err => {\n        isLoaded[route.path] = null\n        reject(err)\n      }\n\n      const onSuccess = res => {\n        isLoaded[route.path] = null\n        resolve(res)\n      }\n\n      if (force || !isLoaded[route.path]) {\n        isLoaded[route.path] = fetch(process.env.GRAPHQL_ENDPOINT, {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({ path, dynamic })\n        })\n          .then(res => res.json())\n      }\n\n      isLoaded[route.path]\n        .then(res => {\n          if (res.errors) onFail(res.errors[0])\n          else if (res.code) onSuccess({ code: res.code })\n          else onSuccess({\n            data: res.data,\n            context: res.extensions\n              ? res.extensions.context\n              : {}\n          })\n          isLoaded[route.path] = null\n        })\n        .catch(onFail)\n    })\n  }\n\n  const hashMeta = document\n    .querySelector('meta[name=\"gridsome:hash\"]')\n    .getAttribute('content')\n\n  return new Promise((resolve, reject) => {\n    const usePath = route.name === '*' ? NOT_FOUND_PATH : route.path\n    const jsonPath = route.meta.dataPath || unslashEnd(usePath) + '/index.json'\n    const absPath = unslashEnd(dataUrl) + jsonPath\n\n    if (shouldPrefetch && !isLoaded[jsonPath]) {\n      if (!isPrefetched[jsonPath]) {\n        isPrefetched[jsonPath] = prefetch(absPath)\n      }\n\n      return isPrefetched[jsonPath]\n        .then(() => resolve())\n        .catch(() => resolve())\n    }\n\n    if (!isLoaded[jsonPath]) {\n      isLoaded[jsonPath] = fetchJSON(absPath)\n    }\n\n    return isLoaded[jsonPath]\n      .then(res => {\n        if (res.hash !== hashMeta) {\n          reject(\n            createError(\n              `Hash did not match: json=${res.hash}, document=${hashMeta}`,\n              'INVALID_HASH'\n            )\n          )\n        } else {\n          resolve(res)\n        }\n      })\n      .catch(err => {\n        isLoaded[jsonPath] = null\n        reject(err)\n      })\n  })\n}\n\nfunction createError (message, code) {\n  const error = new Error(message)\n  error.code = code\n  return error\n}\n\nfunction fetchJSON (jsonPath) {\n  return new Promise((resolve, reject) => {\n    const req = new XMLHttpRequest()\n\n    req.open('GET', jsonPath, true)\n    req.withCredentials = true\n\n    req.onload = () => {\n      switch (req.status) {\n        case 200: {\n          let results\n\n          try {\n            results = JSON.parse(req.responseText)\n          } catch (err) {\n            return reject(\n              new Error(`Failed to parse JSON from ${jsonPath}. ${err.message}.`)\n            )\n          }\n\n          if (!results.hash) {\n            return reject(\n              new Error(`JSON data in ${jsonPath} is missing a hash.`)\n            )\n          }\n\n          return resolve(results)\n        }\n        case 404: {\n          return reject(createError(req.statusText, req.status))\n        }\n      }\n\n      reject(new Error(`Failed to fetch ${jsonPath}.`))\n    }\n\n    req.onerror = () => {\n      reject(new Error(`Failed to fetch ${jsonPath}.`))\n    }\n\n    req.send(null)\n  })\n}\n"],"mappings":"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","ignoreList":[]}]}